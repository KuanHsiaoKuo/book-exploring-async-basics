<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Communicating with the OS - The Node Experiment - Exploring Async Basics with Rust</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li class="chapter-item expanded "><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li class="chapter-item expanded "><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="3_1_communicating_with_the_os.html" class="active"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li class="chapter-item expanded "><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li class="chapter-item expanded "><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li class="chapter-item expanded "><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li class="chapter-item expanded "><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li class="chapter-item expanded "><a href="6_epoll_kqueue_iocp.html"><strong aria-hidden="true">6.</strong> Epoll, Kqueue and IOCP</a></li><li class="chapter-item expanded "><a href="7_0_introducing_our_main_example.html"><strong aria-hidden="true">7.</strong> Introducing our main example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7_1_what_is_node.html"><strong aria-hidden="true">7.1.</strong> What is Node?</a></li><li class="chapter-item expanded "><a href="7_2_whats_our_plan.html"><strong aria-hidden="true">7.2.</strong> What's our plan</a></li></ol></li><li class="chapter-item expanded "><a href="8_0_implementing_our_own_runtime.html"><strong aria-hidden="true">8.</strong> Implementing our own Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="8_1_the_main_loop.html"><strong aria-hidden="true">8.1.</strong> Running our runtime - the main loop</a></li><li class="chapter-item expanded "><a href="8_2_setting_up_runtime.html"><strong aria-hidden="true">8.2.</strong> Setting up our runtime</a></li><li class="chapter-item expanded "><a href="8_3_timers.html"><strong aria-hidden="true">8.3.</strong> Timers</a></li><li class="chapter-item expanded "><a href="8_4_callbacks.html"><strong aria-hidden="true">8.4.</strong> Callbacks</a></li><li class="chapter-item expanded "><a href="8_5_threadpool.html"><strong aria-hidden="true">8.5.</strong> Threadpool</a></li><li class="chapter-item expanded "><a href="8_6_io_eventqueue.html"><strong aria-hidden="true">8.6.</strong> I/O eventqueue</a></li><li class="chapter-item expanded "><a href="8_8_cleaning_up.html"><strong aria-hidden="true">8.7.</strong> Cleaning up</a></li><li class="chapter-item expanded "><a href="8_9_infrastructure.html"><strong aria-hidden="true">8.8.</strong> Infrastructure</a></li></ol></li><li class="chapter-item expanded "><a href="9_0_modules.html"><strong aria-hidden="true">9.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="9_1_file_module.html"><strong aria-hidden="true">9.1.</strong> File module</a></li><li class="chapter-item expanded "><a href="9_2_crypto_module.html"><strong aria-hidden="true">9.2.</strong> Crypto module</a></li><li class="chapter-item expanded "><a href="9_3_http_module.html"><strong aria-hidden="true">9.3.</strong> Http module</a></li></ol></li><li class="chapter-item expanded "><a href="10_putting_pieces_together.html"><strong aria-hidden="true">10.</strong> Putting the pieces together</a></li><li class="chapter-item expanded "><a href="11_final_code.html"><strong aria-hidden="true">11.</strong> Final code</a></li><li class="chapter-item expanded "><a href="12_shortcuts_and_improvements.html"><strong aria-hidden="true">12.</strong> Shortcuts and improvements</a></li><li class="chapter-item expanded affix "><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Node Experiment - Exploring Async Basics with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cfsamson/book-exploring-async-basics" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="communicating-with-the-operating-system"><a class="header" href="#communicating-with-the-operating-system">Communicating with the operating system</a></h1>
<p><strong>In this chapter I want to dive into:</strong></p>
<ul>
<li>What a System Call is</li>
<li>Abstraction levels</li>
<li>Challenges of writing low-level cross-platform code</li>
</ul>
<h2 id="syscall-primer"><a class="header" href="#syscall-primer">Syscall primer</a></h2>
<p>Communication with the operating system is done through <code>System Calls</code> or
&quot;syscalls&quot; as we'll call them from now on. This is a public API that the operating system provides and that programs we write in &quot;userland&quot; can use to communicate with the OS.</p>
<p>Most of the time these calls are abstracted away for us as programmers by the language or the runtime we use. A language like Rust makes it
trivial to make a <code>syscall</code> though which we'll see below.</p>
<p>Now, <code>syscalls</code> is an example of something that is unique to the kernel you're communicating with, but the UNIX family of kernels has many similarities. UNIX systems expose this through <strong><code>libc</code></strong>.</p>
<p>Windows, on the other hand, uses its own API, often referred to as WinAPI, and that can be radically different from how the UNIX based systems operate.</p>
<p>Most often though there is a way to achieve the same things. In terms of functionality, you might not notice a big difference but as we'll see below and especially when we dig into how <code>epoll</code>, <code>kqueue</code> and <code>IOCP</code> work, they can differ a lot in how this functionality is implemented.</p>
<h2 id="syscall-example"><a class="header" href="#syscall-example">Syscall example</a></h2>
<p>To get a bit more familiar with <code>syscalls</code> we'll implement a very basic one for the three architectures: <code>BSD(macos)</code>, <code>Linux</code> and <code>Windows</code>. We'll also see how this is implemented in three levels of abstractions.</p>
<p>The <code>syscall</code> we'll implement is the one used when we write something to <code>stdout</code> since that is such a common operation and it's interesting to see how it really works.</p>
<h3 id="the-lowest-level-of-abstraction"><a class="header" href="#the-lowest-level-of-abstraction">The lowest level of abstraction</a></h3>
<p>For this to work we need to write some <a href="https://doc.rust-lang.org/1.0.0/book/inline-assembly.html">inline assembly</a>. We'll start by focusing on the instructions we write to the CPU.</p>
<blockquote>
<p>If you want a more thorough introduction to inline assembly I can refer you to the <a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/an-example-we-can-build-upon">relevant chapter in my previous book</a> if you haven't read it already.</p>
</blockquote>
<p>Now at this level of abstraction, we'll write different code for all three platforms.</p>
<p>On Linux and macOS the <code>syscall</code> we want to invoke is called <code>write</code>. Both systems operate based on the concept of <code>file descriptors</code> and <code>stdout</code> is one of these already present when you start a process.</p>
<p><strong>On Linux a <code>write</code> syscall can look like this</strong> <br />
(You can run the example by clicking &quot;play&quot; in the right corner)</p>
<pre><pre class="playground"><code class="language-rust  edition2021"><span class="boring">// #![feature(force_mdbook_nightly_playground)]
</span>use std::arch::asm;

fn main() {
    let message = String::from(&quot;Hello world from interrupt!\n&quot;);
    syscall(message);
}

#[cfg(target_os = &quot;linux&quot;)]
#[inline(never)]
fn syscall(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();

    unsafe {
        asm!(
            &quot;mov rax, 1&quot;,      // system call 0x2000004 is write on macos
            &quot;mov rdi, 1&quot;,      // file handle 1 is stdout
            &quot;syscall&quot;,         // call kernel, syscall interrupt
            in(&quot;rsi&quot;) msg_ptr, // address of string to output
            in(&quot;rdx&quot;) len,     // number of bytes
            out(&quot;rax&quot;) _, out(&quot;rdi&quot;) _, lateout(&quot;rsi&quot;) _, lateout(&quot;rdx&quot;) _
        );
    }
}
</code></pre></pre>
<p>The code to initiate the <code>write</code> syscall on Linux is <code>1</code> so when we write <code>1</code> we're writing the literal value 1 to the <code>rax</code> register.</p>
<p>Coincidentally, placing the value <code>1</code> into the <code>rdi</code> register means that we're referring to <code>stdout</code> which is the file descriptor we want to write to. This has nothing to do with the fact that the <code>write</code> syscall also has the code <code>1</code>.</p>
<p>Rusts inline assembly syntax takes a little getting used to but when we write <code>in(&quot;rsi&quot;) msg_ptr</code> and <code>in(&quot;rdx&quot;) len</code> we pass in the address of our string buffer and the length of the buffer in the registers <code>rsi</code> and <code>rdx</code> respectively.</p>
<blockquote>
<p>We also need to clobber the registers we write to so that we let the compiler know that we're modifying them and it can't rely on storing any values in these. We do this by declaring the registers as outputs but with _ instead of a
variable name. We use <code>lateout</code> for the registers that also serve as inputs since a register marked with <code>out</code> can't have an initial value at the start of the assembly block.</p>
</blockquote>
<p>Lastly we call the <code>syscall</code> instruction.</p>
<blockquote>
<p>The <code>syscall</code> instruction is a rather new one. On the earlier 32-bit systems in the <code>x86</code> architecture, you invoked a syscall by issuing a software interrupt <code>int 0x80</code>. A software interrupt is considered slow at the level we're working at here so later a separate instruction for it called <code>syscall</code> was added. The <code>syscall</code> instruction uses <a href="http://articles.manugarg.com/systemcallinlinux2_6.html">VDSO</a>, which is a memory page attached to each process' memory, so no context switch is necessary to execute the system call.</p>
</blockquote>
<p><strong>On macOS, the syscall will look something like this:</strong> <br />
(since the Rust playground is running Linux, we can't run this example here)</p>
<pre><code class="language-rust  ignore">use std::arch::asm;

fn main() {
    let message = String::from(&quot;Hello world from interrupt!\n&quot;);
    syscall(message);
}

#[cfg(target_os = &quot;linux&quot;)]
#[inline(never)]
fn syscall(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();

    unsafe {
        asm!(
            &quot;mov rax, 0x2000004&quot;, // system call 0x2000004 is write on macos
            &quot;mov rdi, 1&quot;,         // file handle 1 is stdout
            &quot;syscall&quot;,            // call kernel, syscall interrupt
            in(&quot;rsi&quot;) msg_ptr,    // address of string to output
            in(&quot;rdx&quot;) len,         // number of bytes
            out(&quot;rax&quot;) _, out(&quot;rdi&quot;) _, lateout(&quot;rsi&quot;) _, lateout(&quot;rdx&quot;) _
        );
    }
}
</code></pre>
<p>As you see this is not that different from the one we wrote for Linux, with the exception of the fact that syscall <code>write</code> has the code <code>0x2000004</code> instead of <code>1</code>.</p>
<p><strong>What about Windows?</strong></p>
<p>This is a good opportunity to explain why writing code like we do above is a bad idea.</p>
<p>You see, if you want your code to work for a long time you have to worry about what <code>guarantees</code> the OS gives you. As far as I know, both Linux and macOS give some guarantees that for example <code>$$0x2000004</code> on macOS will always refer to <code>write</code> (I'm not sure how strong these guarantees are though). Windows gives absolutely zero guarantees when it comes to low-level internals like this.</p>
<p>Windows has changed it's internals numerous times and provides no official documentation. The only thing we got is reverse engineered tables like <a href="https://j00ru.vexillium.org/syscalls/nt/64/">this</a>. That means that what was <code>write</code> can be changed to <code>delete</code> the next time you run Windows update.</p>
<h2 id="the-next-level-of-abstraction"><a class="header" href="#the-next-level-of-abstraction">The next level of abstraction</a></h2>
<p>The next level of abstraction is to use the API which all three operating systems provide for us.</p>
<p>Already we can see that this abstraction helps us remove some code since fortunately for us, in this specific example, the syscall is the same on Linux and on macOS so we only need to worry if we're on Windows and therefore use the <code>#[cfg(not(target_os = &quot;windows&quot;))]</code> conditional compilation flag. For the Windows syscall, we do the opposite.</p>
<h3 id="using-the-os-provided-api-in-linux-and-macos"><a class="header" href="#using-the-os-provided-api-in-linux-and-macos">Using the OS provided API in Linux and macOS</a></h3>
<p>You can run this code directly here in the window. However, the Rust playground
runs on Linux, you'll need to copy the code over to a Windows machine if you
want to try it out the code for Windows further down.</p>
<p><strong>Our syscall will now look like this</strong> <br />
(You can run this code here. It will work for both Linux and macOS)</p>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

// and: http://man7.org/linux/man-pages/man2/write.2.html
#[cfg(not(target_os = &quot;windows&quot;))]
#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}

#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };

    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}

</code></pre></pre>
<p>I'll explain what we just did here. I assume that the <code>main</code> method needs no comment.</p>
<pre><code class="language-rust  ignore">#[link(name = &quot;c&quot;)]
</code></pre>
<p>Every Linux installation comes with a version of <code>libc</code> which is a C-library for communicating with the operating system. Having a <code>libc</code> with a consistent API means they can change the underlying implementation without breaking everyone's code. This flag tells the compiler to link to the &quot;c&quot; library on the system we're compiling for.</p>
<pre><code class="language-rust  ignore">extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize);
}
</code></pre>
<p><code>extern &quot;C&quot;</code> or only <code>extern</code> (C is assumed if nothing is specified) means we're linking to specific functions in the &quot;c&quot; library using the &quot;C&quot; calling convention. As you'll see on Windows we'll need to change this since it uses a different calling convention than the UNIX family.</p>
<p>The function we're linking to needs to have the exact same name, in this case, <code>write</code>. The parameters don't need to have the same name but they must be in
the right order and it's good practice to name them the same as in the library
you're linking to.</p>
<p>The write function takes a <code>file descriptor</code> which in this case is a handle to
<code>stdout</code>. In addition, it expects us to provide a pointer to an array of <code>u8</code> values and the length of the buffer.</p>
<pre><code class="language-rust  ignore">#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall_libc(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe { write(1, msg_ptr, len) };
}
</code></pre>
<p>First, we get a pointer to the underlying buffer of our
string. This will be a pointer of type <code>*const u8</code> which matches our <code>buf</code>
argument. The <code>len</code> of the buffer corresponds to the <code>count</code> argument.</p>
<p>You might ask how we know that <code>1</code> is the file-handle to <code>stdout</code> and where we found that value.</p>
<p>You'll notice this a lot when writing syscalls from Rust. Usually, constants are defined in the C header files which we can't link to, so we need to search them up. 1 is always the file descriptor for <code>stdout</code> on UNIX systems.</p>
<blockquote>
<p>Wrapping the <code>libc</code> functions and providing these constants is exactly what the
crate <a href="https://github.com/rust-lang/libc">libc</a> provides for us and why you'll see that used instead of writing
the type of code we do here.</p>
</blockquote>
<p>A call to an FFI function is always unsafe so we need to use the <code>unsafe</code> keyword
here.</p>
<h3 id="using-the-api-on-windows"><a class="header" href="#using-the-api-on-windows">Using the API on Windows</a></h3>
<p><strong>This syscall will look like this on Windows:</strong> <br />
(You'll need to copy this code over to a Windows machine to try this out)</p>
<pre><code class="language-rust  ignore">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}

#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {

    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;

    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }

        let res = unsafe {
            WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null())
            };
        if res  == 0 {
            return Err(io::Error::last_os_error());
        }

    assert_eq!(output as usize, len);
    Ok(())
}
</code></pre>
<p>Now, just by looking at the code above you see it starts to get a bit more
complex, but let's spend some time to go through line by line what we do here as
well.</p>
<pre><code class="language-rust  ignore">#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
</code></pre>
<p>The first line is just telling the compiler to only compile this if the <code>target_os</code> is Windows.</p>
<p>The second line is a linker directive, telling the linker we want to link to the library <code>kernel32</code> (if you ever see an example that links to <code>user32</code> that will also work).</p>
<pre><code class="language-rust  ignore">extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}
</code></pre>
<p>First of all, <code>extern &quot;stdcall&quot;</code>, tells the compiler that we won't use the <code>C</code>
calling convention but use Windows calling convention called <code>stdcall</code>.</p>
<p>The next part is the functions we want to link to. On Windows, we need to link to two functions to get this to work: <code>GetStdHandle</code> and <code>WriteConsoleW</code>.
<code>GetStdHandle</code> retrieves a reference to a standard device like <code>stdout</code>.</p>
<p><code>WriteConsole</code> comes in two flavours, <code>WriteConsoleW</code> that takes in Unicode text and <code>WriteConsoleA</code> that takes ANSI encoded text.</p>
<p>Now, ANSI encoded text works fine if you only write English text, but as soon as you write text in other languages you might need to use special characters that are not possible to represent in <code>ANSI</code> but is possible in <code>utf-8</code> and our program will break.</p>
<p>That's why we'll convert our <code>utf-8</code> encoded text to <code>utf-16</code> encoded Unicode codepoints that can represent these characters and use the <code>WriteConsoleW</code> function.</p>
<pre><code class="language-rust  ignore">#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;

    let mut output: u32 = 0;
    let handle = unsafe { GetStdHandle(-11) };
    if handle == -1 {
        return Err(io::Error::last_os_error());
    }

    let res = unsafe { WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) };

    if res == 0 {
        return Err(io::Error::last_os_error());
    }

    assert_eq!(output, len);
    Ok(())
}
</code></pre>
<p>The first thing we do is to convert the text to utf-16 encoded text which
Windows uses. Fortunately, Rust has a built-in function to convert our <code>utf-8</code> encoded text to <code>utf-16</code> code points. <code>encode_utf16</code> returns an iterator over  <code>u16</code> code points that we can collect to a <code>Vec</code>.</p>
<pre><code class="language-rust  ignore">let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
let msg_ptr = msg.as_ptr();
let len = msg.len() as u32;
</code></pre>
<p>Next, we get the pointer to the underlying buffer of our <code>Vec</code> and get the
length.</p>
<pre><code class="language-rust  ignore">let handle = unsafe { GetStdHandle(-11) };
if handle  == -1 {
    return Err(io::Error::last_os_error())
}
</code></pre>
<p>The next is a call to <code>GetStdHandle</code>. We pass in the value <code>-11</code>. The values we
need to pass in for the different standard devices is actually documented
together with the <code>GetStdHandle</code> documentation:</p>
<table><thead><tr><th>Handle</th><th>Value</th></tr></thead><tbody>
<tr><td>Stdin</td><td>-10</td></tr>
<tr><td>Stdout</td><td>-11</td></tr>
<tr><td>StdErr</td><td>-12</td></tr>
</tbody></table>
<p>Now we're lucky here, it's not that common that we find this information
together with the documentation for the function we call, but it's very convenient when we do.</p>
<p>The return codes to expect is also documented thoroughly for all functions so we handle potential errors here in the same way as we did for the Linux/macOS syscalls.</p>
<pre><code class="language-rust  ignore">let res = unsafe {
    WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null())
};

if res == 0 {
    return Err(io::Error::last_os_error());
}
</code></pre>
<p>Next up is the call to the <code>WriteConsoleW</code> function. There is nothing too fancy about this.</p>
<h2 id="the-highest-level-of-abstraction"><a class="header" href="#the-highest-level-of-abstraction">The highest level of abstraction</a></h2>
<p>This is simple, most standard libraries provide this abstraction for you. In rust that would simply be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello world from Stdlib&quot;);
<span class="boring">}
</span></code></pre></pre>
<h1 id="our-finished-cross-platform-syscall"><a class="header" href="#our-finished-cross-platform-syscall">Our finished cross-platform syscall</a></h1>
<pre><pre class="playground"><code class="language-rust">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

// and: http://man7.org/linux/man-pages/man2/write.2.html
#[cfg(not(target_os = &quot;windows&quot;))]
#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}

#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };

    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}

#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}

#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;

    let mut output: u32 = 0;
    let handle = unsafe { GetStdHandle(-11) };
    if handle == -1 {
        return Err(io::Error::last_os_error());
    }

    let res = unsafe { WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) };

    if res == 0 {
        return Err(io::Error::last_os_error());
    }

    assert_eq!(output, len);
    Ok(())
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="3_0_the_operating_system.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="3_2_cross_platform_abstractions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="3_0_the_operating_system.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="3_2_cross_platform_abstractions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>


        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-149686420-1', 'auto');
                ga('send', 'pageview');
            }
        </script>


        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
